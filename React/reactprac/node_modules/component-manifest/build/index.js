
(function(
  // Reliable reference to the global object (i.e. window in browsers).
  global,

  // Dummy constructor that we use as the .constructor property for
  // functions that return Generator objects.
  GeneratorFunction
) {
  var hasOwn = Object.prototype.hasOwnProperty;

  if (global.wrapGenerator) {
    return;
  }

  function wrapGenerator(innerFn, self) {
    return new Generator(innerFn, self || null);
  }

  global.wrapGenerator = wrapGenerator;
  if (typeof exports !== "undefined") {
    exports.wrapGenerator = wrapGenerator;
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  wrapGenerator.mark = function(genFun) {
    genFun.constructor = GeneratorFunction;
    return genFun;
  };

  // Ensure isGeneratorFunction works when Function#name not supported.
  if (GeneratorFunction.name !== "GeneratorFunction") {
    GeneratorFunction.name = "GeneratorFunction";
  }

  wrapGenerator.isGeneratorFunction = function(genFun) {
    var ctor = genFun && genFun.constructor;
    return ctor ? GeneratorFunction.name === ctor.name : false;
  };

  function Generator(innerFn, self) {
    var generator = this;
    var context = new Context();
    var state = GenStateSuspendedStart;

    function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        throw new Error("Generator has already finished");
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          try {
            var info = delegate.generator[method](arg);

            // Delegate generator ran and handled its own exceptions so
            // regardless of what the method was, we continue as if it is
            // "next" with an undefined arg.
            method = "next";
            arg = void 0;

          } catch (uncaught) {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = uncaught;

            continue;
          }

          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedStart &&
              typeof arg !== "undefined") {
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
            throw new TypeError(
              "attempt to send " + JSON.stringify(arg) + " to newborn generator"
            );
          }

          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            delete context.sent;
          }

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = void 0;
          }
        }

        state = GenStateExecuting;

        try {
          var value = innerFn.call(self, context);

          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: value,
            done: context.done
          };

          if (value === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = void 0;
            }
          } else {
            return info;
          }

        } catch (thrown) {
          if (method === "next") {
            context.dispatchException(thrown);
          } else {
            arg = thrown;
          }
        }
      }
    }

    generator.next = invoke.bind(generator, "next");
    generator.throw = invoke.bind(generator, "throw");
  }

  Generator.prototype.toString = function() {
    return "[object Generator]";
  };

  function Context() {
    this.reset();
  }

  Context.prototype = {
    constructor: Context,

    reset: function() {
      this.next = 0;
      this.sent = void 0;
      this.tryStack = [];
      this.done = false;
      this.delegate = null;

      // Pre-initialize at least 20 temporary variables to enable hidden
      // class optimizations for simple generators.
      for (var tempIndex = 0, tempName;
           hasOwn.call(this, tempName = "t" + tempIndex) || tempIndex < 20;
           ++tempIndex) {
        this[tempName] = null;
      }
    },

    stop: function() {
      this.done = true;

      if (hasOwn.call(this, "thrown")) {
        var thrown = this.thrown;
        delete this.thrown;
        throw thrown;
      }

      return this.rval;
    },

    keys: function(object) {
      return Object.keys(object).reverse();
    },

    pushTry: function(catchLoc, finallyLoc, finallyTempVar) {
      if (finallyLoc) {
        this.tryStack.push({
          finallyLoc: finallyLoc,
          finallyTempVar: finallyTempVar
        });
      }

      if (catchLoc) {
        this.tryStack.push({
          catchLoc: catchLoc
        });
      }
    },

    popCatch: function(catchLoc) {
      var lastIndex = this.tryStack.length - 1;
      var entry = this.tryStack[lastIndex];

      if (entry && entry.catchLoc === catchLoc) {
        this.tryStack.length = lastIndex;
      }
    },

    popFinally: function(finallyLoc) {
      var lastIndex = this.tryStack.length - 1;
      var entry = this.tryStack[lastIndex];

      if (!entry || !hasOwn.call(entry, "finallyLoc")) {
        entry = this.tryStack[--lastIndex];
      }

      if (entry && entry.finallyLoc === finallyLoc) {
        this.tryStack.length = lastIndex;
      }
    },

    dispatchException: function(exception) {
      var finallyEntries = [];
      var caught = false;

      if (this.done) {
        throw exception;
      }

      // Dispatch the exception to the "end" location by default.
      this.thrown = exception;
      this.next = "end";

      for (var i = this.tryStack.length - 1; i >= 0; --i) {
        var entry = this.tryStack[i];
        if (entry.catchLoc) {
          this.next = entry.catchLoc;
          caught = true;
          break;
        } else if (entry.finallyLoc) {
          finallyEntries.push(entry);
        }
      }

      while ((entry = finallyEntries.pop())) {
        this[entry.finallyTempVar] = this.next;
        this.next = entry.finallyLoc;
      }

      return caught;
    },

    delegateYield: function(generator, resultName, nextLoc) {
      this.delegate = {
        generator: generator,
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
}).apply(this, Function("return [this, function GeneratorFunction(){}]")());

var fs = require('graceful-fs');
var resolve = require('path').resolve;
var unglobDirectory = require('unglob').directory;

/**
 * Convert a branch from `component-resolver`
 * into a "manifest" object.
 * Each manifest object will have a list of files,
 * which the builder will iterate over.
 *
 * `options` should be passed directly from the resolver.
 *
 */

module.exports = function Manifest(options) {
  wrapGenerator.mark(unglob);

  return wrapGenerator.mark(function createManifest(branch) {
    var manifest;

    return wrapGenerator(function createManifest$($ctx0) {
      while (1) switch ($ctx0.next) {
      case 0:
        manifest = {
          // cross referencing
          branch: branch,
          node: branch.node,
          path: branch.path,
          name: branch.canonical,
        };

        return $ctx0.delegateYield(unglob(manifest), "t0", 2);
      case 2:
        createFiles(manifest);
        $ctx0.rval = manifest;
        delete $ctx0.thrown;
        $ctx0.next = 7;
        break;
      case 7:
      case "end":
        return $ctx0.stop();
      }
    }, this);
  });

  /**
   * Unglob the `fields` of the component
   * and populate manifest.field.
   *
   * @param {Object} branch
   * @api private
   */

  function unglob(manifest) {
    var branch, node, dev, fields;

    return wrapGenerator(function unglob$($ctx1) {
      while (1) switch ($ctx1.next) {
      case 0:
        branch = manifest.branch;
        node = manifest.node;

        dev = (options.dev
          && branch.type === 'local'
          && node.development)
          || {};

        fields = {};

        options.fields.forEach(function (field) {
          var paths = [];
          if (node[field]) paths = paths.concat(node[field]);
          if (dev[field]) paths = paths.concat(dev[field]);
          fields[field] = unglobDirectory(paths, branch.path);
        });

        $ctx1.next = 7;
        return fields;
      case 7:
        manifest.field = $ctx1.sent;
      case 8:
      case "end":
        return $ctx1.stop();
      }
    }, this);
  }

  /**
   * Convert all the paths in `manifest.field`
   * into file objects, then populate `manifest.files`.
   *
   * @param {Object} branch
   * @api private
   */

  function createFiles(manifest) {
    var branch = manifest.branch;
    var fields = manifest.field;
    var files = [];

    options.fields.forEach(function (field) {
      var objs =
      fields[field] = fields[field].map(toFileObject);
      files = files.concat(objs);
    });

    manifest.files = files;

    function toFileObject(path) {
      var file = {
        path: path, // path according to component.json
        manifest: manifest,
        branch: branch,
        node: branch.node,
        filename: resolve(branch.path, path),
        extension: path.split('.').pop(),
      };

      file.read = read(file);

      return file;
    }
  }
}

/**
 * Populate `file.string` asynchronously by doing `yield file.read`.
 * If you want to use a caching mechanism here or something
 * for reloads, you can overwrite this method.
 *
 * @param {Object} file
 * @api public
 */;

/**
 * Populate `file.string` asynchronously by doing `yield file.read`.
 * If you want to use a caching mechanism here or something
 * for reloads, you can overwrite this method.
 *
 * @param {Object} file
 * @api public
 */

function read(file) {
  var string;
  return function (done) {
    // already read
    if (typeof file.string === 'string') return done(null, file.string);
    if (typeof string === 'string') return done(null, string);
    fs.readFile(file.filename, 'utf8', function (err, str) {
      if (err) {
        return done(new Error('failed to read "'
          + file.manifest.name
          + '"\'s file "'
          + file.path
          + '"'));
      }
      done(null, string = str);
    })
  }
}
